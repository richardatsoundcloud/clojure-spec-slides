<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clojure Spec</title>

    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
        margin: 0 40px 40px 40px;
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        margin: 0;
      }
      h1 {
        font-size: 4em;
        margin-top: 45px;
        margin-bottom: 45px;
      }
      h2 {
        font-size: 2.5em;
        margin-bottom: 25px;
      }
      h3 {
        font-size: 1.8em;
        margin-bottom: 25px;
      }
      section {
        margin-bottom: 45px;
      }

      section.subsection {
        margin-bottom: 25px;
      }

      code {
        font-family: 'Ubuntu Mono';
      }

      ul.resources, ul.resources li {
        list-style-type: none;
        margin: 0;
        margin: 5px 0;
      }

      p {
        margin: 0 15px 20px;
      }

      .codealong p {
        margin-left: 0;
      }

      pre.klipse-wrapper {
        margin-bottom: 35px;
      }

      .CodeMirror {
        padding: 7px;
      }


    </style>

</head>
<body>

  <h1>Clojure Spec — like Racket contracts, but for Clojure</h1>

  <section>
    <h2>What spec is: a set of tools that</h2>

    <div class="content">

      <p>Describes the shape of data declaratively (something along the lines of what Schema does)</p>

      <p>Makes heavy use of existing predicates</p>

      <p>Validates data</p>

      <p>Destructures and adds context to data (more on that later)</p>

      <p>"Instruments" functions and macros</p>

      <p>Drives generative testing with <code>test.check</code>, by providing a lot of the generators for free</p>

    </div>
  </section>



  <section>
    <h2>What spec isn't</h2>

    <div class="content">

      <p><em>A type system</em></p>

      <p>For better or worse, Clojure is dynamic.</p>

      <p>specs are checked at runtime, not compile-time (although you use most of it in dev only, so not that much overhead)</p>

      <p><strong>Benefits:</strong> You can iterate quickly and flexibly and you have a lot of power to do what you want with the reduced syntax and the few simple datatypes that you recombine and compose throughout your code.</p>

      <p><strong>Drawbacks:</strong> Types not checked at compile time, with all that that entails. You have to apply your own discipline. </p>

      <p>spec is an attempt to help you with that discipline, without enforcing that you ever use it.</p>

    </div>

  </section>


  <section>
    <h2>The dream</h2>

    <div class="content">

      <p>One of the ultimate goals with spec is that you can apply as much of a type system as you want in cases where it makes sense

      <p>You can even apply more restrictions than a type system would in a case where you might want to have more to say about a function signature than <code>Int -> Int</code></p>

      <p>And you can dispense with it when it would just get in the way.</p>

      <p>In any case, it's an interesting precedent for how a dynamic language might handle these issues.</p>

    </div>
  </section>



  <section>
    <h2>Let's get to it:</h2>

    <div class="codealong">


      <pre class="klipse-wrapper"><code class="klipse">
      ;; require the spec namespace and give it an alias

      (require '[cljs.spec :as s])
      </code></pre>


      <p>specs can be built-in predicates:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      ;; This is a spec: int?

      (s/valid? int? 76)
      </code></pre>


      <p>specs can be custom predicates:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      ;; This is a spec: (fn [n] (< n 100))

      (s/valid? (fn [n] (< n 100)) 76)
      </code></pre>


      <p>They can also be composed using one of a small set of provided macros, like <code>s/and</code>:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      ;; This is also a spec: (s/and int? even? (fn [n] (< n 100)))

      (s/valid? (s/and int? even? (fn [n] (< n 100))) 76)
      </code></pre>


      <p><code>s/explain</code> (in all of its forms) will tell you which part of your spec failed:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      ;; s/explain, s/explain-str, s/explain-data

      (s/explain (s/and int? even? (fn [n] (< n 100))) 75)
      </code></pre>


      <p>Specs can also be identified by keywords -- fully qualified keywords with namespaces, so they can function as a global registry of specs:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      ;; This is also a spec: :fun-with-math/reasonably-sized

      (s/def :fun-with-math/reasonably-sized (fn [n] (< n 100)))
      (s/valid? :fun-with-math/reasonably-sized 75)
      </code></pre>


      <p>And composed:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      (s/def :fun-with-math/tiny-even-int (s/and int? even? :fun-with-math/reasonably-sized))
      (s/explain :fun-with-math/tiny-even-int 76)
      </code></pre>

    </div>

  </section>

  <section>
    <h2>(Quick aside on fully qualified keywords)</h2>

    <div class="content">

      <p>Keywords are unique identifiers. They start with colons, like symbols in Ruby:</p>

      <p>Fully qualified keywords are two words separated by a slash - the first part is the name of a namespace, like a module in JavaScript or (sort of) like a class in Java or Ruby.</p>

    </div>

    <div class="codealong">

      <p>An unqualified keyword (sadly got thumbs-downs all around at the hiring sync):</p>

      <pre class="klipse-wrapper"><code class="klipse">
      :hi-there
      </code></pre>

      <p>A more qualified keyword (we hope she decides to work here):</p>

      <pre class="klipse-wrapper"><code class="klipse">
      :my-namespace/hi-there
      </code></pre>

    </div>

    <div class="content">

      <p>(Note: The namespace itself doesn't have to be loaded, or even to exist, in order for you to reference a fully-qualified keyword)</p>

      <p>Keywords are often used as the keys in maps. Fully qualified ones help to avoid data collisions, as in the map <code>{:http/method :get, :cooking/method :bake}</code>.</p>

      <p>The stress on the use of fully-qualified keywords as keys in maps that get validated by specs is one of the more controversial parts of Clojure spec. We'll get to that later.</p>

    </div>

  </section>



  <section>
    <h2>Recap</h2>

    <p>These things work as specs</p>

    <ul>
      <li>Predicates</li>
      <li>Return values of built-in macros like <code>s/and</code>, <code>s/coll-of</code>, <code>s/cat</code> (which we'll get to in a minute), and a few others</li>
      <li>Fully qualified keywords that have been bound to specs</li>
    </ul>

    </div>

  </section>

  <section>
    <h2>Now for some actual nested data structures</h2>

    <div class="codealong">

      <p>A recipe:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      (def tomato-sauce-recipe
        {:cooking/ingredients [[250 :g "peeled tomatoes"]
                               [3 :clove "garlic"]
                               [5 :g "pepper"]]
         :cooking/steps ["heat a pan"
                         "throw everything in"
                         "stir"]})
      tomato-sauce-recipe
      </code></pre>

      <p>And some specs to go along with it:</p>

      <pre class="klipse-wrapper"><code class="klipse">
      (s/def :cooking/recipe (s/keys :req [:cooking/ingredients]
                                     :opt [:cooking/steps]))

      (s/def :cooking/ingredients (s/coll-of :cooking/ingredient :kind sequential?))

      (s/def :cooking/ingredient (s/cat :amount number?
                                        :unit   keyword?
                                        :name   string?))

      (s/def :cooking/steps (s/coll-of string? :kind sequential?))

      (s/explain :cooking/recipe tomato-sauce-recipe)

      </code></pre>

      <p>The data destructuring and enhancing feature, which is used in many ways throughout spec: <code>conform</code></p>

      <pre class="klipse-wrapper"><code class="klipse">
      (s/conform :cooking/recipe tomato-sauce-recipe)

      </code></pre>



    </div>


  </section>

  <section>
    <h2>Let's break that down:</h2>
    <section class="subsection">
      <h3>coll-of</h3>

      <div class="codealong">


      <p>For homogeneous collections of arbitrary size - takes constraining parameters:</p>

        <pre class="klipse-wrapper"><code class="klipse">
        ;; #{} and #{4 5 6} are sets in Clojure.

        (s/explain (s/coll-of string?) #{"a" "b" "c"})
        </code></pre>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/explain (s/coll-of string? :min-count 2) #{"a" "b" "c"})
        </code></pre>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/explain (s/coll-of string? :kind sequential?) ["a" "b" "c"])
        </code></pre>

      </div>

    </section>

    <section class="subsection">
      <h3>cat</h3>

      <div class="codealong">


        <p>For heterogeneous tuples where order is semantically important (argument lists, etc.):</p>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/explain (s/cat :first-name string? :last-name string? :defining-feature keyword?)
                   ["Richard" "Harrington" :shiny])
        </code></pre>

        <p>(Note: <code>s/cat</code> uses regular expression semantics, and there are all kinds of other operators like <code>s/*</code>, <code>s/+</code>, <code>s/?</code>, etc., which we won't go into.)</p>

      </div>



    </section>

    <section class="subsection">
      <h3>keys</h3>

      <div class="codealong">

        <p>This is where it gets a little weird.</p>

        <p>Takes a required and an optional sequence of required fully-qualified keywords <strong>which are registered as specs and are also the key names in the map that is being validated</strong>.</p>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/def :people/first-name string?)
        (s/def :people/last-name string?)
        (s/def :people/middle-name string?)

        (s/def :people/full-name (s/keys :req [:people/first-name :people/last-name]
                                         :opt [:people/middle-name]))

        (s/explain :people/full-name {:people/first-name "Richard"
                                      :people/middle-initial "T"
                                      :people/last-name "Harrington"})

        </code></pre>

        <p>Note that the <code>:opt</code> list is just for documentation and for use in creating test cases in generative tests. spec will run a check on every value it finds whose key is a registered spec, whether it was listed in <code>:opt</code> or not:</p>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/explain :people/full-name {:people/first-name "Richard"
                                      :people/last-name "Harrington"
                                      :fun-with-math/tiny-even-int 9})

        </code></pre>

      </div>

      <div class="content">
        <p>This is a little controversial. The justification for it is, according to Rich Hickey (the author of Clojure), </p>
        <blockquote>"Most systems for specifying structures conflate the specification of the key set with the specification of the values designated by those keys. This is a major source of rigidity and redundancy."
        </blockquote>

        <p>That may be the case, but the fact is, very few people currently use namespaced keywords for their map keys. This library pushes people hard in the direction of their use, but in the meantime, there's an alternate way to declare keyset specs, <code>req-un</code> and <code>opt-un</code>.</p>

      </div>

    </section>
    <section class="subsection">

      <div class="codealong">
        <p>When using these variants, namespaced keys are used to look up the specs, but the keys in the map may be unqualified keywords:</p>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/def :people/full-name-un (s/keys :req-un [:people/first-name :people/last-name]
                                            :opt-un [:people/middle-name]))

        (s/explain :people/full-name-un {:first-name "Richard"
                                         :middle-initial "T"
                                         :last-name "Harrington"})

        </code></pre>

      </div>

    </section>

    <section>
      <h2>Generation!</h2>

      <div class="codealong">
        <p>We're not going to go too much into spec's generative testing features through integration with <code>test.check</code>, but here's a taste.</p>

        <p>Each example is a two-part vector with the generated test case, and the conformed version:</p>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/exercise int? 5)

        </code></pre>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/exercise :people/full-name 5)

        </code></pre>

        <pre class="klipse-wrapper"><code class="klipse">
        (s/exercise :cooking/recipe 5)

        </code></pre>

      </div>

    </section>

    <section>
      <h2>Things we probably won't get to today</h2>

      <p>Function specs</p>
      <p>Instrumenting of functions</p>
      <p>Running property-based tests</p>
    </section>


    <!--  TODO: go over that piece by piece
           show function specs and instrumenting
           show actual property-based testing
           get that slide from Stu Halloway's talk about the benefits of spec
           show the ways that you'd actually get started with this, at the end

           -->



  </section>

  <h2>Actually getting started:</h2>

  <p>ClojureScript is easier, because spec is included in the most recent stable release. Just get a repl going and type</p>

  <pre><code>(require '[cljs.spec :as s])</code></pre>

  <p>and you're all set to go.</p>

  <p>The best way to get started immediately with ClojureScript (and the Clojure family in general) is to use the Planck repl, in the resources below. It boots up a ClojureScript repl in half a second, making use of the Mac OS X's existing JavaScriptCore engine.</p>

  <p>If you are using Clojure and leiningen, keep in mind that the most recent stable release of Clojure does NOT have spec, so if you generate a default project you'll have to go into the <code>project.clj</code> and change the Clojure version by adding this to your dependencies:</p>

  <pre><code>:dependencies [[org.clojure/clojure "1.9.0-alpha15"]]</code></pre>

  <p>Then, in your files where you want to use spec:</p>

  <pre><code>(require '[clojure.spec :as s])</code></pre>





  <h1>Resources</h1>

  <ul class="resources">
    <li><a href="https://clojure.org/guides/spec">The Clojure spec Guide</a></li>
    <li><a href="https://clojure.org/about/spec">The Clojure spec Rationale</a></li>
    <li><a href="https://clojure.github.io/clojure/branch-master/clojure.spec-api.html">The Clojure spec Docs</a></li>
    <li><a href="https://vimeo.com/195711510">The obligatory Rich Hickey talk</a></li>
    <li><a href="https://github.com/stuarthalloway/presentations/wiki/Agility-&-Robustness:-Clojure---spec">Some more opinionated slides and videos</a></li>
    <li><a href="https://news.ycombinator.com/item?id=11753963">The obligatory back-and-forth Hacker News thread</a></li>
    <li><a href="http://martintrojer.github.io/clojure/2016/06/14/some-thoughts-on-clojurespec">Some guy's slightly skeptical blog post</a></li>
    <li><a href="http://arnebrasseur.net/talks/2016-clojutre/">A suspiciously familiar slide deck</a></li>
    <li><a href="https://github.com/mfikes/planck">Planck</a> — the absolute quickest way to get up and running with Clojure(Script) and spec and a repl</li>
    <li>Last but not least, hats off to <a href="https://github.com/viebel/klipse">Klipse</a> for its awesome and easy-to-set-up inline coding. Works with a whole bunch of dynamically typed languages and, strangely, C++.</li>
  </ul>




  <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">

  <script>
      window.klipse_settings = {
          selector: '.klipse',
          codemirror_options_in: {
              lineWrapping: true,
              autoCloseBrackets: true
          }
      }
  </script>
  <script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>



</body>
</html>