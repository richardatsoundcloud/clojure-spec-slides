<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clojure Spec</title>

    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
        margin: 0;
      }
      h1 {
        font-size: 4em;
        margin-bottom: 35px;
      }
      h2 {
        font-size: 2.5em;
        margin-bottom: 25px;
      }
      h3 {
        font-size: 1.8em;
        margin-bottom: 15px;
      }
      section {
        margin-bottom: 45px;
      }

      section.subsection {
        margin-bottom: 25px;
      }

      code {
        font-family: 'Ubuntu Mono';
      }

      ul.resources, ul.resources li {
        list-style-type: none;
        margin: 0;
        margin: 5px 0;
      }

      p {
        margin: 0 15px 15px;
      }

      .codealong p {
        margin-left: 0;
      }

      pre {
        margin-bottom: 25px;
      }


    </style>

</head>
<body>

  <h1>Clojure Spec â€” like Racket contracts, but for Clojure</h1>

  <section>
    <h2>What spec is: a set of tools that</h2>

    <div class="content">

      <p>Describes the shape of data declaratively (something along the lines of what Schema does)</p>

      <p>Makes heavy use of existing predicates</p>

      <p>Validates data</p>

      <p>Destructures and adds context to data (more on that later)</p>

      <p>"Instruments" functions and macros</p>

      <p>Drives generative testing with <code>test.check</code>, by providing a lot of the generators for free</p>

    </div>
  </section>



  <section>
    <h2>What spec isn't</h2>

    <div class="content">

      <p><em>A type system</em></p>

      <p>For better or worse, Clojure is dynamic.</p>

      <p>specs are checked at runtime, not compile-time (although you use most of it in dev only, so not that much overhead)</p>

      <p><strong>Benefits:</strong> You can iterate quickly and flexibly and you have a lot of power to do what you want with the reduced syntax and the few simple datatypes that you recombine and compose throughout your code.</p>

      <p><strong>Drawbacks:</strong> Types not checked at compile time, with all that that entails. You have to apply your own discipline. </p>

      <p>spec is an attempt to help you with that discipline, without enforcing that you ever use it.</p>

    </div>

  </section>


  <section>
    <h2>The dream</h2>

    <div class="content">

      <p>One of the ultimate goals with spec is that you can apply as much of a type system as you want in cases where it makes sense

      <p>You can even apply more restrictions than a type system would in a case where you might want to have more to say about a function signature than <code>Int -> Int</code></p>

      <p>And you can dispense with it when it would just get in the way.</p>

      <p>In any case, it's an interesting precedent for how a dynamic language might handle these issues.</p>

    </div>
  </section>



  <section>
    <h2>Let's get to it:</h2>

    <div class="codealong">


      <pre><code class="klipse">
      ;; require the spec namespace and give it an alias

      (require '[cljs.spec :as s])
      </code></pre>


      <p>specs can be built-in predicates:</p>

      <pre><code class="klipse">
      ;; This is a spec: int?

      (s/valid? int? 76)
      </code></pre>


      <p>specs can be custom predicates:</p>

      <pre><code class="klipse">
      ;; This is a spec: (fn [n] (< n 100))

      (s/valid? (fn [n] (< n 100)) 76)
      </code></pre>


      <p>They can also be composed using one of a small set of provided macros, like <code>s/and</code>:</p>

      <pre><code class="klipse">
      ;; This is also a spec: (s/and int? even? (fn [n] (< n 100)))

      (s/valid? (s/and int? even? (fn [n] (< n 100))) 76)
      </code></pre>


      <p><code>s/explain</code> (in all of its forms) will tell you which part of your spec failed:</p>

      <pre><code class="klipse">
      ;; s/explain, s/explain-str, s/explain-data

      (s/explain (s/and int? even? (fn [n] (< n 100))) 75)
      </code></pre>


      <p>Specs can also be identified by keywords -- fully qualified keywords with namespaces, so they can function as a global registry of specs:</p>

      <pre><code class="klipse">
      ;; This is also a spec: :fun-with-math/reasonably-sized

      (s/def :fun-with-math/reasonably-sized (fn [n] (< n 100)))
      (s/valid? :fun-with-math/reasonably-sized 75)
      </code></pre>


      <p>And composed:</p>

      <pre><code class="klipse">
      (s/def :fun-with-math/tiny-even-int (s/and int? even? :fun-with-math/reasonably-sized))
      (s/explain :fun-with-math/tiny-even-int 76)
      </code></pre>

    </div>

  </section>

  <section>
    <h2>(Quick aside on fully qualified keywords)</h2>

    <div class="content">

      <p>Keywords are unique identifiers. They start with colons, like symbols in Ruby:</p>

      <p>Fully qualified keywords are two words separated by a slash - the first part is the name of a namespace, like a module in JavaScript or (sort of) like a class in Java or Ruby.</p>

    </div>

    <div class="codealong">

      <p>An unqualified keyword (sadly got thumbs-downs all around at the hiring sync):</p>

      <pre><code class="klipse">
      :hi-there
      </code></pre>

      <p>A more qualified keyword (we hope she decides to work here):</p>

      <pre><code class="klipse">
      :my-namespace/hi-there
      </code></pre>

    </div>

    <div class="content">

      <p>(Note: The namespace itself doesn't have to be loaded, or even to exist, in order for you to reference a fully-qualified keyword)</p>

      <p>Keywords are often used as the keys in maps. Fully qualified ones help to avoid data collisions, as in the map <code>{:http/method :get, :cooking/method :bake}</code>.</p>

      <p>The stress on the use of fully-qualified keywords as keys in maps that get validated by specs is one of the more controversial parts of Clojure spec. We'll get to that later.</p>

    </div>

  </section>



  <section>
    <h2>Recap</h2>

    <p>These things work as specs</p>

    <ul>
      <li>Predicates</li>
      <li>Return values of built-in macros like <code>s/and</code>, <code>s/coll-of</code>, <code>s/cat</code> (which we'll get to in a minute), and a few others</li>
      <li>Fully qualified keywords that have been bound to specs</li>
    </ul>

    </div>

  </section>

  <section>
    <h2>Now for some actual nested data structures</h2>

    <div class="codealong">

      <p>A recipe:</p>

      <pre><code class="klipse">
      (def tomato-sauce-recipe
        {:cooking/ingredients [[250 :g "peeled tomatoes"]
                               [3 :clove "garlic"]
                               [5 :g "pepper"]]
         :cooking/steps ["heat a pan"
                         "throw everything in"
                         "stir"]})
      tomato-sauce-recipe
      </code></pre>

      <p>And some specs to go along with it:</p>

      <pre><code class="klipse">
      (s/def :cooking/recipe (s/keys :req [:cooking/ingredients]
                                     :opt [:cooking/steps]))

      (s/def :cooking/ingredients (s/coll-of :cooking/ingredient :kind sequential?))

      (s/def :cooking/ingredient (s/cat :amount number?
                                        :unit   keyword?
                                        :name   string?))

      (s/def :cooking/steps (s/coll-of string? :kind sequential?))

      (s/explain :cooking/recipe tomato-sauce-recipe)

      </code></pre>

      <!--  TODO: go over that piece by piece
             show conform, try to kind of explain it
             show generators
             show function specs and instrumenting
             show actual property-based testing
             get that slide from Stu Halloway's talk about the benefits of spec
             show the ways that you'd actually get started with this, at the end

             -->

    </div>


  </section>

  <section>
    <h2>Let's break that down:</h2>
    <section class="subsection">
      <h3>coll-of</h3>

      <div class="codealong">


      <p>For homogeneous collections of arbitrary size - takes constraining parameters:</p>

        <pre><code class="klipse">
        ;; #{} and #{4 5 6} are sets in Clojure.

        (s/explain (s/coll-of string?) #{"a" "b" "c"})
        </code></pre>

        <pre><code class="klipse">
        (s/explain (s/coll-of string? :min-count 2) #{"a" "b" "c"})
        </code></pre>

        <pre><code class="klipse">
        (s/explain (s/coll-of string? :kind sequential?) ["a" "b" "c"])
        </code></pre>

      </div>

    </section>

    <section class="subsection">
      <h3>cat</h3>

      <div class="codealong">


        <p>For heterogeneous tuples where order is semantically important (argument lists, etc.):</p>

        <pre><code class="klipse">
        (s/explain (s/cat :first-name string? :last-name string? :defining-feature keyword?)
                   ["Richard" "Harrington" :shiny])
        </code></pre>

        <p>(Note: <code>s/cat</code> uses regular expression semantics, and there are all kinds of other operators like <code>s/*</code>, <code>s/+</code>, <code>s/?</code>, etc., which we won't go into.)</p>

      </div>



    </section>

    <section class="subsection">
      <h3>keys</h3>

      <div class="codealong">

        <p>This is where it gets a little weird.</p>

        <p>Takes a required and an optional sequence of required fully-qualified keywords <strong>which are registered as specs and are also the key names in the map that is being validated</strong>.</p>

        <pre><code class="klipse">
        (s/def :people/first-name string?)
        (s/def :people/last-name string?)
        (s/def :people/middle-name string?)

        (s/def :people/full-name (s/keys :req [:people/first-name :people/last-name]
                                         :opt [:people/middle-name]))

        (s/explain :people/full-name {:people/first-name "Richard"
                                      :people/middle-initial "T"
                                      :people/last-name "Harrington"})

        </code></pre>

        <p>Note that the <code>:opt</code> list is just for documentation, as far as I know. spec will run a check on every value it finds whose key is a registered spec:</p>

        <pre><code class="klipse">
        (s/explain :people/full-name {:people/first-name "Richard"
                                      :people/last-name "Harrington"
                                      :fun-with-math/tiny-even-int 9})

        </code></pre>





       (s/def :people/first-name string?)
       (s/def :people/last-name string?)
       (s/def :people/middle-name string?)

       (s/def :people/full-name (s/keys :req [:people/first-name :people/last-name]
                                        :opt [:people/middle-initial]))

       (s/explain :people/full-name {:people/first-name "Richard"
                                     :people/middle-initial "T"
                                     :fun-with-math/tiny-even-int 9
                                     :people/last-name "Harrington"})

      </div>

    </section>

  </section>


  <h1>Resources</h1>

  <ul class="resources">
    <li><a href="https://clojure.org/guides/spec">The Clojure spec Guide</a></li>
    <li><a href="https://clojure.org/about/spec">The Clojure spec Rationale</a></li>
    <li><a href="https://clojure.github.io/clojure/branch-master/clojure.spec-api.html">The Clojure spec Docs</a></li>
    <li><a href="https://vimeo.com/195711510">The obligatory Rich Hickey talk</a></li>
    <li><a href="https://news.ycombinator.com/item?id=11753963">The obligatory Hacker News thread</a></li>
    <li><a href="http://martintrojer.github.io/clojure/2016/06/14/some-thoughts-on-clojurespec">Some guy's blog post</a></li>
    <li><a href="http://arnebrasseur.net/talks/2016-clojutre/">A suspiciously familiar slide deck</a></li>
    <li><a href="https://github.com/mfikes/planck">Planck</a> â€” the absolute quickest way to get up and running with Clojure(Script) and spec and a repl</li>
    <li>Last but not least, hats off to <a href="https://github.com/viebel/klipse">Klipse</a> for its awesome and easy-to-set-up inline coding. Works with a whole bunch of dynamically typed languages and, strangely, C++.</li>
  </ul>




  <link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">

  <script>
      window.klipse_settings = {
          selector: '.klipse',
          codemirror_options_in: {
              lineWrapping: true,
              autoCloseBrackets: true
          }
      }
  </script>
  <script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>



</body>
</html>